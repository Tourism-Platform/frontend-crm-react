# Архитектурный гид и паттерны проекта

Данный документ описывает ключевые архитектурные решения и паттерны, использованные в проекте. Он служит эталоном для масштабирования и создания новых функциональных блоков.

---

## 1. Методология: Feature-Sliced Design (FSD)

Проект строго следует методологии FSD. Основные правила:
- **Разделение на слои**: `app`, `pages`, `widgets`, `features`, `entities`, `shared`.
- **Однонаправленный поток зависимостей**: Верхние слои могут импортировать только из нижних (например, `entities` не может импортировать из `features`).
- **Группировка по доменам (Domain Grouping)**: Если в рамках одного слоя (например, `pages` или `widgets`) появляется много сущностей, относящихся к одному функциональному домену (например, `tours`, `booking`), они объединяются в общую директорию домена. Внутри этой директории каждый слайс сохраняет свою структуру.
- **Публичное API**: Каждый модуль должен иметь `index.ts` (Barrel export), через который осуществляется доступ к его содержимому. Прямые импорты из внутренностей модуля запрещены.

### Структура слоя model
Для обеспечения масштабируемости слоя `model` внутри модулей (виджетов, фич, сущностей) применяются следующие правила:
- **Базовая структура (до 3-х файлов)**: Если в `model` присутствуют только основные файлы, они располагаются в корне:
  - `config.ts`
  - `schemes.ts` (или `schema.ts`)
  - `types.ts`
- **Расширенная структура (4 и более файлов)**: При росте количества файлов необходимо создавать соответствующие подпапки:
  - `config/`
  - `schemes/`
  - `types/`
- **Именование в подпапках**: Файлы внутри подпапок именуются по паттерну `[смысловое-имя].[тип].ts`. Например: `user.config.ts`, `auth.types.ts`. Это позволяет легко идентифицировать ответственность файла даже при открытии множества вкладок.

### Конфигурация путей (ENUM_PATH)
Все пути в приложении централизованно описаны в `src/shared/config/routes/routes.config.ts`.
- **Вложенная структура**: Пути организованы иерархически по функциональным модулям (например, `SETTINGS`, `TOURS`, `BOOKING`). Это позволяет структурировать роутинг и избегать коллизий.
- **Корневые пути (ROOT)**: Каждый модуль имеет ключ `ROOT`, указывающий на базовый путь этого раздела.
- **Динамические параметры**: Параметры (например, `:tourId`, `:eventId`) вкладываются в соответствующие части объекта.
- **Стили именования**: Используется `as const` для обеспечения строгой типизации при использовании путей в компонентах.

Пример структуры:
```typescript
export const ENUM_PATH = {
  TOURS: {
    ROOT: "/tours",
    OVERVIEW: "/tours/:tourId/overview",
    EVENTS: {
      ROOT: "/tours/:tourId/itinerary/events",
      FLIGHT: "/tours/:tourId/itinerary/events/:eventId/flight",
    }
  }
} as const;
```

## 2. Роутинг и Навигация

### Структура
- Конфигурация роутов вынесена в `src/app/router/router.config.tsx`.
- Используется декларативный подход через массивы объектов с типизацией путей.
- **Protected Routes**: Доступ к защищенным страницам контролируется оберткой `ProtectedRoute`, которая проверяет состояние авторизации.

### Паттерн роута
```typescript
{
  path: ENUM_PATH.TOURS,
  component: ToursPage,
  auth: ENUM_AUTH.PRIVATE,
  layout: ENUM_LAYOUT.ROOT,
  layout_cascade: [ToursOwnerLayout]
}
```

### Каскадные лейауты (Layout Cascade)
Для реализации сложной вложенности интерфейсов (например, когда страница находится внутри сайдбара, который находится внутри основного контура приложения) используется массив `layout_cascade`.
- Компоненты в массиве оборачивают страницу последовательно.
- Это позволяет гибко настраивать окружение страницы без дублирования кода в самих компонентах страниц.

## 3. Провайдеры и Глобальное Состояние

### Композиция провайдеров
Используется паттерн HOC (Higher-Order Component) и библиотека `compose-function` для предотвращения "ада из оберток" (Provider Hell). Провайдеры настраиваются в `src/app/providers/index.ts`.

### State Management
- **Глобальный стейт**: Redux Toolkit (RTK).
- **Domain logic**: Слайсы стейта располагаются внутри сущностей (`entities`).
- **Server Cache**: RTK Query. Базовая конфигурация в `src/shared/api/backend/base.api.ts`.

## 4. Интернационализация (i18n)

### Принципы
- **Локализация по блокам**: JSON-файлы разделены по функциональным областям (настройкам, турам, финансам).
- **Строгая типизация**: Ключи перевода типизированы через `TNestedKeyOf`, что обеспечивает автодополнение и защиту от ошибок при использовании `t('key')`.
- **Загрузка**: Используется `i18next-http-backend` для динамической подгрузки чанков переводов.

### Структура папок (Пример)
```text
public/locales/
├── en/
│   ├── booking/        # Переводы для модуля бронирования
│   │   ├── orders.json
│   │   └── appeals.json
│   ├── finance/        # Переводы для финансового модуля
│   ├── settings/       # Переводы для настроек
│   ├── tours/          # Переводы для туров и событий
│   ├── common.json     # Общие переводы
│   └── sidebar.json    # Переводы бокового меню
└── ru/                 # Аналогичная структура для русского языка
```

### Регистрация блоков (i18n.blocks.ts)
Для управления путями к чанкам переводов используется объект `TRANSLATION_BLOCKS`. Он позволяет группировать namespace в логические блоки (папки).
```typescript
export const TRANSLATION_BLOCKS: Record<string, ITranslationBlock> = {
  settings: {
    folder: "settings",
    namespaces: ["security_page", "account_settings_page"]
  },
  tours: {
    folder: "tours",
    namespaces: ["tours_page", "tour_overview_page"]
  }
};
```

### Конфигурация ресурсов и типов (i18n.config.ts)
Здесь происходит связывание JSON-файлов с типами для обеспечения полной поддержки TypeScript.
1. **Импорт и типизация**:
```typescript
import header from "../../../../public/locales/en/header.json";

export type THeader = typeof header;
export type THeaderKeys = TNestedKeyOf<THeader>;
```
2. **Сборка ресурсов**:
```typescript
export type TResources = {
  header: THeader;
  settings_page: TSettingsPage;
  // ...
};

export const NS = ["header", "settings_page", ...] as const;
```

## 5. UI-паттерны (Config-driven UI)

Это ключевой паттерн проекта, позволяющий минимизировать дублирование кода и упростить поддержку.

### Формы и поля
Компонент `CustomField` в `shared/ui` является универсальной точкой входа для всех элементов форм.
- Логика отображения (Input, Select, DatePicker и т.д.) управляется через `fieldType`.
- Формы строятся на базе массивов конфигураций (Data Lists), где описываются ключи, лейблы и типы полей.

### Таблицы
Компонент `SmartTable` построен на базе `@tanstack/react-table`.
- **Конфигурация столбцов**: Выносится в `model/config` конкретного виджета.
- **Поддержка режимов**: Переключение между табличным видом и видом карточек (`cards`).
- **Интегрированные фильтры и пагинация**: Автоматическое управление состоянием фильтров.

## 6. Работа со стилями

- **Tailwind CSS 4**: Используется для всей стилизации.
- **Утилита `cn`**: Обязательна для манипуляций с классами (комбинация `clsx` и `tailwind-merge`).
- **Shadcn UI**: Базовый набор UI-компонентов (`src/shared/ui/shadcn-ui`).

## 7. Стилизация и Темизация

Для обеспечения корректной работы смены тем (Light/Dark) и поддержки дизайн-системы, агент должен следовать строгим правилам стилизации:

- **Использование переменных**: Стилизация должна выполняться исключительно с использованием переменных дизайн-системы, прописанных в Tailwind (например, `bg-background`, `text-primary`, `border-border`).
- **Запрет на ad-hoc цвета**: Запрещено использовать стандартные именованные цвета Tailwind (например, `bg-slate-200`, `text-blue-500`) в коде компонентов, если это не запрошено пользователем напрямую.
- **Интеграция с темами**: Все используемые переменные должны иметь соответствующие значения в `src/shared/styles/theme.css` для селекторов `:root` и `.dark`. Это гарантирует автоматическое обновление интерфейса при смене темы.
- **Шрифты и размеры**: Использовать системные переменные для отступов и размеров шрифтов (`text-sm`, `p-4` и т.д.), которые привязаны к CSS-переменным в `variables.css`.

---

## Рекомендации по разработке новых фич

1. **Создание новой сущности**: 
   - Начни с определения типов в `entities/[name]/types`.
   - Создай стейт в `entities/[name]/model/slice`.
   - Вынеси переиспользуемые фрагменты UI в `entities/[name]/ui`.
2. **Создание виджета**: 
   - Собери UI из компонентов `shared` и `entities`.
   - Если это форма/таблица, опиши конфигурацию в `model/config`.
3. **Регистрация страницы**:
   - Добавь путь в `shared/config/routes`.
   - Опиши роут в `app/router/router.config.tsx`.
